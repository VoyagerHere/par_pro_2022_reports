\documentclass[oneside,final,14pt]{extreport}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{vmargin}
\setpapersize{A4}
\setmarginsrb{2cm}{1.5cm}{1cm}{1.5cm}{0pt}{0mm}{0pt}{13mm}
\usepackage{indentfirst}
\usepackage{amsmath}
\usepackage{float}
% Matlab code
\sloppy
\usepackage{hyperref}
\usepackage {titlesec}
\titleformat{\chapter}{\hyphenpenalty=10000\normalfont\huge\bfseries}{\thechapter. }{0pt}{\Huge}
\makeatother


\usepackage{pgfplots}
\pgfplotsset{compat=1.9}




% Preamble



\begin{document}


\begin{titlepage}
\centering{Министерство науки и высшего образования Российской Федерации}
\vskip0.2cm
\centering{Федеральное государственное автономное образовательное учреждение высшего образования \dq Национальный исследовательский Нижегородский государственный университет им. Н.И. Лобачевского\dq (ННГУ)}
\vskip0.2cm
\centering{Институт информационных технологий, математики и механики}
\vskip0.2cm
\centering{Направление подготовки: \dq Фундаментальная информатика и информационные технологии\dq}
\Large
\vfill
\centering{{\bf Отчёт по лабораторной работе}}
\vskip0.2cm
\centering{Тема: <<Быстрая сортировка с четно-нечетным слиянием Бэтчера>> }
\normalsize
\vfill
\vfill
\begin{flushright}
\textbf{Выполнил:}\\
студент группы 382006-2\\
Колесников Денис Евгеньевич\\
\vspace{0.5cm}
\textbf{Проверил:}\\
младший научный сотрудник\\
Нестеров А.Ю.\\
\end{flushright}
\vfill
\centering{Нижний Новгород}\\
\centering{2023 г.}
\end{titlepage}


\tableofcontents

\chapter{Введение}
Сортировка является одной из типовых проблем обработки данных и обычно понимается как задача размещения элементов неупорядоченного набора значений 
\begin{displaymath}
    S =\{a_1,a_2,...,a_n\}
\end{displaymath}
в порядке монотонного возрастания или убывания. 
\begin{displaymath}
S \sim S^{'}=\{ \{a_{1}^{'},a_{2}^{'},...,a_{n}^{'}\}:a_{1}^{'}<=a_{2}^{'}<=...<=a_{n}^{'}\}
\end{displaymath}
В данной работе рассмотрим метод быстрой сортировки с четно-нечетным слиянием Бэтчера.
\chapter{Постановка задачи}
Написать программу, сортирующую массив элементов с помощью быстрой сортировки и слиянием Бэтчера, с использованием методов параллельного программирования. Для этого разработать параллельный алгоритм данной сортировки. Затем сравнить время выполнения на нескольких процессах, определить ускорение.

Программа должна использовать интерфейс MPI для эффективной работы на системах с распределенной памятью.
\chapter{Описание алгоритмов}
\section{Описание алгоритма быстрой сортировки}
Используем стратегию "разделяй и властвуй". Шаги алгоритма:
\begin{enumerate}
    \item Выбираем в массиве некоторый элемент, который будем называть опорным элементом. С точки зрения корректности алгоритма выбор опорного элемента безразличен. С точки зрения повышения эффективности алгоритма выбираться должна медиана, но без дополнительных сведений о сортируемых данных её обычно невозможно получить. Известные стратегии: выбирать постоянно один и тот же элемент, например, средний или последний по положению; выбирать элемент со случайно выбранным индексом.
    \item Операция разделения массива: реорганизуем массив таким образом, чтобы все элементы, меньшие или равные опорному элементу, оказались слева от него, а все элементы, большие опорного — справа от него. Обычный алгоритм операции:
        \begin{enumerate}
            \item Два индекса — l и r, приравниваются к минимальному и максимальному индексу разделяемого массива соответственно.
            Вычисляется индекс опорного элемента m.
            \item       Индекс l последовательно увеличивается до m до тех пор, пока l-й элемент не превысит опорный.
            \item         Индекс r последовательно уменьшается до m до тех пор, пока r-й элемент не окажется меньше либо равен опорному.
            \item         Если r = l — найдена середина массива — операция разделения закончена, оба индекса указывают на опорный элемент.
            \item         Если l < r — найденную пару элементов нужно обменять местами и продолжить операцию разделения с тех значений l и r, которые были достигнуты. Следует учесть, что если какая-либо граница (l или r) дошла до опорного элемента, то при обмене значение m изменяется на r-й или l-й элемент соответственно. 
        \end{enumerate}
    \item     Рекурсивно упорядочиваем подмассивы, лежащие слева и справа от опорного элемента.
    \item Базой рекурсии являются наборы, состоящие из одного или двух элементов. Первый возвращается в исходном виде, во втором, при необходимости, сортировка сводится к перестановке двух элементов. Все такие отрезки уже упорядочены в процессе разделения.
\end{enumerate}
Поскольку в каждой итерации (на каждом следующем уровне рекурсии) длина обрабатываемого отрезка массива уменьшается, по меньшей мере, на единицу, терминальная ветвь рекурсии будет достигнута всегда и обработка гарантированно завершится.        

\section{Описание алгоритма слияния Бэтчера}

Алгоритм слияния Бэтчера  основан на алгоритме слияния, который
объединяет две отсортированные половины последовательности в полностью отсортированную последовательность.
В отличие от сортировки слиянием, этот алгоритм не зависит от данных, т.е. одни и те же сравнения выполняются независимо от фактических данных. Таким образом, нечетная четная сортировка слияний может быть реализована как сортировочная сеть.


Следующий алгоритм объединяет последовательность, две половины которой отсортированы, в отсортированную последовательность:
\bigskip

На вход алгоритма подаётся последовательность \(a_0,a_2,...,a_{n-1}\) длины \(n-1\) где \(a_0,a_2,...,a_{n/2 - 1}\), \(a_{n/2},a_{n/2 + 1},...,a_{n-1}\) отсротирвоанные половины (\(n\) кратно \(2\))
\begin{enumerate}
    \item Если \(n>2\) тогда:
    \begin{enumerate}
        \item Применяем слияния Бэтчера рекурсивно к чётной последовательности \(a_0,a_2,...,a_{n-2}\) и к нечётной \(a_1,a_3,...,a_{n-1}\)
        \item Сравниваем \([a_i;a_{i+1}]\) для всех \(i \in \{1,3,5,7,..,n-3\}\)
    \end{enumerate}
    \item Или сравниваем \([a_0;a_{1}]\)
\end{enumerate}

\chapter{Описание схемы распараллеривания}
Суть параллельной реализации данной сортировки заключается в следующем: для начала выполняется передача, разбиение массива элементов по всем процессам. Каждый процесс параллельно сортирует свой массив последовательным алгоритмом быстрой сортировки.

После этого мы имеем несколько отсортированных массивов. Теперь задача состоит в слиянии этих массивов в один, результирующий. Собираем отсортированные блоки на одном процессе и складываем их в массив.
Слияние будет проводиться итерационно: на первом шаге блоки данных делятся на пары, и производим слияния правого массива с левым. На втором шаге также объединяем блоки данных в пары, но только те, которые были левыми на первом шаге. Производим слияние правого блока с левым. Это выполняется до тех пор, пока не останется один блок данных. Он и будет результатом параллельной сортировки.
\chapter{Описание программной реализации на MPI}

Каждый процесс будет иметь свой массив под данные для последовательной сортировки. Чтобы его получить делим количество данных на количество процессов.
\bigskip

Далее выделям память под массив полученного размера.
\bigskip

С помощью функции MPI\_Scatter() каждый процесс получает блок данных полученного размера.
\bigskip
Производим последовательную сортировку локальных данных на каждом процессе.
\bigskip
Процесс с рангом \(0\) с импользованием фукции MPI\_Recv() собирает отсортированные на процессах блоки в один массив блоков.

Процессы с ненулевым рангом с помощью функции MPI\_Send() отправляют процессу с рангом \(0\) свой уже отсортированный блок данных.
\bigskip

Произодим попарное слияние блоков данных пока не останется один блок. Он будет результатом работы программы

\chapter{Результаты экспериментов}

Эксперимент производился на операционной системе Ubuntu Linux. Колчество данных для сортировки было равно \(2^{20}\). Время работы параллельного алгоритма было замерено с помощью функции MPI\_Wtime() на разном колчестве процессов.
\begin{center}
    \begin{tabular}{|c||c|c|c||c|c|} \hline
        Кол-во процессов & 1  & 2  & 3  & Среднее & Отн. ускорение \\ \hline \hline
        1 & 3.006150 & 2.952572 & 2.974901 & 2.977874 & 1 \\ \hline
        2 & 1.055688 & 1.072760 & 1.073688 & 1.067378 & 2.78 \\ \hline
        4 & 0.587931 & 0.581494 & 0.587931 & 0.583221 & 5.10 \\ \hline
    \end{tabular}   
\end{center}
\chapter{Вывод из результатов}
При параллельном запуске программы мы получили существенное ускорение. Если количество данных для сортировки уменьшить, например до \(2^{10}\) разница будет почти несущественна, или оказаться даже хуже при параллельном запуске из-за затрат на переключение контекста.
\chapter{Заключение}
В ходе лабораторной работы были описаны алгоритмы быстрой сортировки и четно-нечетного слияния Бэтчера. Реализована параллельная схема алгоритмов на языке C++ с использованием MPI.
\bigskip

Таким образом при грамотном распределении ресурсов параллельная схема позволяет значительно ускорить время работы программы. 
\chapter{Литература}
\begin{enumerate}
    \item Официальный сайт: Центр суперкомпьютерных технологий
    \url{http://www.hpcc.unn.ru}
    \item Сайт mpich.org \url{https://www.mpich.org}
    \item Лекции WesternMichiganUniversity \url{https://cs.wmich.edu/}
\end{enumerate}
\chapter{Приложение}
Реализация программы представлена на github:
\url{https://github.com/VoyagerHere/par_pro_2022_mpi/tree/kolesnikov_d_q_batcher_sort}

\end{document}

